#include  <iostream>using namespace std;#define maxn 40001int a[maxn],temp[maxn];int sum=0,n;int MergePass(int left,int mid,int right){    int k=0,i=left,j=mid+1;///将ij分别固定到a数组中的相应位置    while(i<=mid && j<=right)    {        if(a[i]<a[j])///不是逆序队不需要进行考虑            temp[k++] = a[i++];        else        {            temp[k++] = a[j++];            sum += (mid-i+1);///如果a[i]>a[j]那么a[i]后面的元素都大于a[j],a[i]后面的元素有mid-i+1个        }    }    ///剩余部分加进去    while(i<=mid)        temp[k++] = a[i++];    while(j<=right)        temp[k++] = a[j++];    for(int i=0;i<k;i++)        a[left+i] = temp[i];///最后将这段改动的数据仍然放在a数组中}void MergeSort(int left,int right){    if(left<right)    {        int mid = (left+right)/2;        ///先分段二分        MergeSort(left,mid);        MergeSort(mid+1,right);        ///分好了进行排序        MergePass(left,mid,right);    }}int main(){    cin>>n;    for(int i=1;i<=n;i++)        cin>>a[i];    MergeSort(1,n);    cout<<sum<<endl;    return 0;}#include<iostream>usingnamespacestd;#definemaxn40001inta[maxn],temp[maxn];intsum=0,n;intMergePass(intleft,intmid,intright){intk=0,i=left,j=mid+1;///将ij分别固定到a数组中的相应位置while(i<=mid&&j<=right){if(a[i]<a[j])///不是逆序队不需要进行考虑temp[k++]=a[i++];else{temp[k++]=a[j++];sum+=(mid-i+1);///如果a[i]>a[j]那么a[i]后面的元素都大于a[j],a[i]后面的元素有mid-i+1个}}///剩余部分加进去while(i<=mid)temp[k++]=a[i++];while(j<=right)temp[k++]=a[j++];for(inti=0;i<k;i++)a[left+i]=temp[i];///最后将这段改动的数据仍然放在a数组中}voidMergeSort(intleft,intright){if(left<right){intmid=(left+right)/2;///先分段二分MergeSort(left,mid);MergeSort(mid+1,right);///分好了进行排序MergePass(left,mid,right);}}intmain(){cin>>n;for(inti=1;i<=n;i++)cin>>a[i];MergeSort(1,n);cout<<sum<<endl;return0;}#include<iostream>usingnamespacestd;#definemaxn40001inta[maxn],temp[maxn];intsum=0,n;intMergePass(intleft,intmid,intright){intk=0,i=left,j=mid+1;///将ij分别固定到a数组中的相应位置while(i<=mid&&j<=right){if(a[i]<a[j])///不是逆序队不需要进行考虑temp[k++]=a[i++];else{temp[k++]=a[j++];sum+=(mid-i+1);///如果a[i]>a[j]那么a[i]后面的元素都大于a[j],a[i]后面的元素有mid-i+1个}}///剩余部分加进去while(i<=mid)temp[k++]=a[i++];while(j<=right)temp[k++]=a[j++];for(inti=0;i<k;i++)a[left+i]=temp[i];///最后将这段改动的数据仍然放在a数组中}voidMergeSort(intleft,intright){if(left<right){intmid=(left+right)/2;///先分段二分MergeSort(left,mid);MergeSort(mid+1,right);///分好了进行排序MergePass(left,mid,right);}}intmain(){cin>>n;for(inti=1;i<=n;i++)cin>>a[i];MergeSort(1,n);cout<<sum<<endl;return0;}#include<iostream>usingnamespacestd;#definemaxn40001inta[maxn],temp[maxn];intsum=0,n;intMergePass(intleft,intmid,intright){intk=0,i=left,j=mid+1;///将ij分别固定到a数组中的相应位置while(i<=mid&&j<=right){if(a[i]<a[j])///不是逆序队不需要进行考虑temp[k++]=a[i++];else{temp[k++]=a[j++];sum+=(mid-i+1);///如果a[i]>a[j]那么a[i]后面的元素都大于a[j],a[i]后面的元素有mid-i+1个}}///剩余部分加进去while(i<=mid)temp[k++]=a[i++];while(j<=right)temp[k++]=a[j++];for(inti=0;i<k;i++)a[left+i]=temp[i];///最后将这段改动的数据仍然放在a数组中}voidMergeSort(intleft,intright){if(left<right){intmid=(left+right)/2;///先分段二分MergeSort(left,mid);MergeSort(mid+1,right);///分好了进行排序MergePass(left,mid,right);}}intmain(){cin>>n;for(inti=1;i<=n;i++)cin>>a[i];MergeSort(1,n);cout<<sum<<endl;return0;}